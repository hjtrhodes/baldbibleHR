const bcrypt = require("bcrypt"); // import bcrypt
const jwt = require("jsonwebtoken"); // import jsonwebtoken
const User = require("../models/user"); // import the User model, which is exported from user.js

exports.signup = async (req, res, next) => {
  const password = req.body.password;

  // Password requirements
  const passwordRegex = /^(?=.*[A-Z])(?=.*[!@#$%^&*(),.?":{}|<>]).{8,}$/;

  if (!passwordRegex.test(password)) {
    return res.status(400).json({
      message:
        'Password must be at least 8 characters, contain at least one uppercase character and one special character.',
    });
  }

  try {
    // Check if email or username already exist in the database
    const existingUser = await User.findOne({
      $or: [{ email: req.body.email }, { username: req.body.username }],
    });

    if (existingUser) {
      // User with the same email or username already exists
      return res.status(409).json({
        message: 'Email or username already exists. Please choose a different one.',
      });
    }

    // If no existing user, proceed with user creation
    const hash = await bcrypt.hash(password, 10);
    const newUser = new User({
      firstName: req.body.firstName,
      lastName: req.body.lastName,
      email: req.body.email,
      password: hash,
      username: req.body.username,
    });

    await newUser.save();
    return res.status(201).json({ message: 'User added successfully!' });
  } catch (error) {
    return res.status(500).json({ error: error.message || 'Internal Server Error' });
  }
};

exports.login = (req, res, next) => {
  // call the post method, which adds a route to the router object, to handle POST requests to the /api/auth/login endpoint
  User.findOne({ email: req.body.email }) // call the findOne method, which returns a promise, which resolves to the User object with the specified email
    .then((user) => {
      // call the then method, which adds a callback function to the promise, to handle the success case
      if (!user) {
        // if the user does not exist
        return res.status(401).json({ error: "User not found!" }); // return a 401 Unauthorized error
      } // end of if (!user) { ... }
      bcrypt
        .compare(req.body.password, user.password) // call the compare method, which returns a promise, which resolves to a boolean indicating if the password matches the hash
        .then((valid) => {
          // call the then method, which adds a callback function to the promise, to handle the success case
          if (!valid) {
            // if the password does not match the hash
            return res.status(401).json({ error: "Incorrect password!" }); // return a 401 Unauthorized error
          } // end of if (!valid) { ... }
          const token = jwt.sign(
            // call the sign method, which returns a token
            { userId: user._id }, // set the userId property of the token to the _id property of the User object
            "RANDOM_TOKEN_SECRET", // set the secret key used to generate the token
            { expiresIn: "3h" }, // set the expiration time of the token
          ); // end of const token = jwt.sign( ... )
          res.status(200).json({
            // return a 200 OK status code and a JSON object
            userId: user._id, // set the userId property of the JSON object to the _id property of the User object
            token, // set the token property to the token generated by the sign method
            username: user.username,
          }); // end of res.status(200).json({ ... })
        }) // end of .then(valid => { ... })
        .catch((error) => res.status(500).json({ error: error })); // call the catch method, which adds a callback function to the promise, to handle the failure case
    }) // end of .then(user => { ... })
    .catch((error) => res.status(500).json({ error: error })); // call the catch method, which adds a callback function to the promise, to handle the failure case
}; // end of exports.login = (req, res, next) => { ... }
